def warn(*args, **kwargs):
    pass
import warnings
warnings.warn = warn

import warnings

import pandas as pd
import pickle
import dill
from sklearn.model_selection import train_test_split
from sklearn import tree
from sklearn.metrics import accuracy_score
from sklearn.metrics import auc, roc_curve
import sys 
import dask.dataframe as dd
from sklearn import preprocessing 
#dta normalization tool
from sklearn.preprocessing import StandardScaler
# Neural Network api
from sklearn.neural_network import MLPClassifier
from sklearn.ensemble import RandomForestClassifier


# metrics
from sklearn.metrics import classification_report,confusion_matrix
from sklearn.feature_extraction import DictVectorizer
from sklearn.model_selection import KFold

from keras.models import Sequential
from keras.layers import Dense
from keras.callbacks import EarlyStopping
import numpy as np
#Donot modify the method signatures and return dtypes
#you can include additional functions of your choice


class MalwareDetectionModel:
    
    
    def __init__(self):
       self.dtypes = {
               'MachineIdentifier':                                     'category', # Not Required in Classification
               'ProductName':                                           'object', # Required in Classification
                'EngineVersion':                                        'object', # Required in Classification
                'AppVersion':                                           'object', # Required in Classification
                'AvSigVersion':                                         'object', # Required in Classification
                'IsBeta':                                               'float16', 
                'RtpStateBitfield':                                     'float64',
                'IsSxsPassiveMode':                                     'float16',
                'DefaultBrowsersIdentifier':                            'float64',
                'AVProductStatesIdentifier':                            'float64',
                'AVProductsInstalled':                                  'float64',
                'AVProductsEnabled':                                    'float64',
                'HasTpm':                                               'float64',
                'CountryIdentifier':                                    'float64',
                'CityIdentifier':                                       'float64',
                'OrganizationIdentifier':                               'float64',
                'GeoNameIdentifier':                                    'float64',
                'LocaleEnglishNameIdentifier':                          'float64',
                'Platform':                                             'object',
                'Processor':                                            'object',
                'OsVer':                                                'object',
                'OsBuild':                                              'float64',
                'OsSuite':                                              'float64',
                'OsPlatformSubRelease':                                 'object',
                'OsBuildLab':                                           'object',
                'SkuEdition':                                           'object',
                'IsProtected':                                          'float16',
                'AutoSampleOptIn':                                      'float64',
                'PuaMode':                                              'object',
                'SMode':                                                'float64',
                'IeVerIdentifier':                                      'float64',
                'SmartScreen':                                          'object',
                'Firewall':                                             'float64',
                'UacLuaenable':                                         'float64',
                'Census_MDC2FormFactor':                                'object',
                'Census_DeviceFamily':                                  'object',
                'Census_OEMNameIdentifier':                             'float64',
                'Census_OEMModelIdentifier':                            'float64',
                'Census_ProcessorCoreCount':                            'float64',
                'Census_ProcessorManufacturerIdentifier':               'float64',
                'Census_ProcessorModelIdentifier':                      'float64',
                'Census_ProcessorClass':                                'object',
                'Census_PrimaryDiskTotalCapacity':                      'float64',
                'Census_PrimaryDiskTypeName':                           'object',
                'Census_SystemVolumeTotalCapacity':                     'float64',
                'Census_HasOpticalDiskDrive':                           'float64',
                'Census_TotalPhysicalRAM':                              'float64',
                'Census_ChassisTypeName':                               'object',
                'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float64',
                'Census_InternalPrimaryDisplayResolutionHorizontal':    'float64',
                'Census_InternalPrimaryDisplayResolutionVertical':      'float64',
                'Census_PowerPlatformRoleName':                         'object',
                'Census_InternalBatteryType':                           'object',
                'Census_InternalBatteryNumberOfCharges':                'float64',
                'Census_OSVersion':                                     'object',
                'Census_OSArchitecture':                                'object',
                'Census_OSBranch':                                      'object',
                'Census_OSBuildNumber':                                 'float64',
                'Census_OSBuildRevision':                               'float64',
                'Census_OSEdition':                                     'object',
                'Census_OSSkuName':                                     'object',
                'Census_OSInstallTypeName':                             'object',
                'Census_OSInstallLanguageIdentifier':                   'float64',
                'Census_OSUILocaleIdentifier':                          'float64',
                'Census_OSWUAutoUpdateOptionsName':                     'object',
                'Census_IsPortableOperatingSystem':                     'float16',
                'Census_GenuineStateName':                              'object',
                'Census_ActivationChannel':                             'object',
                'Census_IsFlightingInternal':                           'float16',
                'Census_IsFlightsDisabled':                             'float16',
                'Census_FlightRing':                                    'object',
                'Census_ThresholdOptIn':                                'float64',
                'Census_FirmwareManufacturerIdentifier':                'float64',
                'Census_FirmwareVersionIdentifier':                     'float64',
                'Census_IsSecureBootEnabled':                           'float16',
                'Census_IsWIMBootEnabled':                              'float16',
                'Census_IsVirtualDevice':                               'float16',
                'Census_IsTouchEnabled':                                'float16',
                'Census_IsPenCapable':                                  'float16',
                'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',
                'Wdft_IsGamer':                                         'float64',
                'Wdft_RegionIdentifier':                                'float64',
               #fill in the data types for the rest of the columns
                'HasDetections':                                        'int8'
               }
       
       #define the model in class level so all the methods can use it.
#       self.clf = tree.DecisionTreeClassifier(max_depth=5)
       self.clf = RandomForestClassifier(n_estimators=10, max_depth=3,bootstrap=True)
       self.mlp = MLPClassifier(hidden_layer_sizes=(13,13,13),max_iter=500)# I tried with 500 on test data
       self.labelEncoder = preprocessing.LabelEncoder()
       #standardization of data -- similar process for normalizaition
       self.scaler = StandardScaler()
       
       self.model = Sequential()
  
    
    
    def handleCategoricalData(self,data):
      #handling categorical data types columns
      vectorizer = DictVectorizer( sparse = False )
      categorical = list(data.select_dtypes(include=['object']).columns.values)
      print("categorical:",categorical)
      for category in categorical:
          data[category].fillna("NA", inplace=True)
          data[category] = [x.replace('.', '') for x in data[category]]
          #handling fields with combined String + float
          data[category] = self.labelEncoder.fit_transform(data[category].astype(str))
#          data[category] = vectorizer.fit_transform( data[category].astype(str))
          
      non_categorical = list(data.select_dtypes(include=['float64','float32','float16']).columns.values)
      print("non_categorical:",non_categorical)
      for nonCat in non_categorical:
          mean_val = np.mean(data[nonCat])
          #median_val = np.median(data[nonCat])
          if(np.isnan(mean_val)):
              mean_val = 0
              #np.around(mean_val, decimals=0)
          mean_val = round(mean_val, 2)
          print("mean_val:",mean_val," - column:",nonCat)
          data[nonCat].fillna(mean_val, inplace=True)
          
      return data
      
  #trains a model, you can access the malware_train.csv file for training your model
    def train(self):
      fileName = sys.argv[1]

    # TODO clean up the input file in details and analysis of the NAN and empty or similar values
      
#      df = pd.DataFrame()
#      for chunk in pd.read_csv(fileName, names=['id', 'text', 'code'], index_col=0, engine='python', chunksize=1000):
#          df = pd.concat([df, chunk], ignore_index=True)
#      data = dd.read_csv(fileName, dtype=self.dtypes)
      
    
      data = pd.read_csv(fileName, dtype=self.dtypes)
#      print(data.describe().transpose())
      
      #drop only when everything is NAN
      data = data.dropna(how='all')

      data = data[['SmartScreen',
                   'AVProductsInstalled',
                   'AVProductStatesIdentifier',
                   'AvSigVersion',
                   'EngineVersion',
                   'Census_TotalPhysicalRAM',
                   'Census_InternalPrimaryDiagonalDisplaySizeInInches',
                   'Census_PrimaryDiskTotalCapacity',
                   'Processor',
                   'Census_OSArchitecture',
                   'AppVersion',
                   'Census_SystemVolumeTotalCapacity',
                   'Census_IsAlwaysOnAlwaysConnectedCapable',
                   'Census_ProcessorCoreCount',
                   'Census_PowerPlatformRoleName',
                   'IsProtected',
#                   'Census_ProcessorModelIdentifier',
#                   'Census_IsVirtualDevice',
#                   'AVProductsEnabled',
#                   'Wdft_IsGamer',
#                   'Census_InternalPrimaryDisplayResolutionHorizontal',
#                   'RtpStateBitfield',
#                   'Census_ActivationChannel',
#                   'OsBuildLab',
#                   'Census_IsTouchEnabled',
#                   'Census_OSEdition',
#                   'Census_OSVersion',
#                   'Census_OSBuildRevision',
				   'HasDetections']]
    
      
#      data = data.drop('MachineIdentifier',axis=1)
      data = data.loc[:, data.isnull().mean() < .9]
      data.replace([np.inf, -np.inf], np.nan)
    
#      
      print("Number of rows in data [Before Data Cleaning - But converting NAN/INF]:", data.shape[0])
      #convertng categories/Strings to numbers for classifications
#      data['ProductName'] = data['ProductName'].replace(self.map_to_int_col_2_ProductName)
#      data['EngineVersion'] = data['EngineVersion'].replace(self.map_to_int_col_3_EngineVersion)
      
#      data = self.handleCategoricalData(data)
#      vectorizer = DictVectorizer( sparse = False )
      categorical = list(data.select_dtypes(include=['object']).columns.values)
      print("categorical:",categorical)
      for category in categorical:
          data[category].fillna("NA", inplace=True)
          data[category] = [x.replace('.', '') for x in data[category]]
          #handling fields with combined String + float
          data[category] = self.labelEncoder.fit_transform(data[category].astype(str))
          
      non_categorical = list(data.select_dtypes(include=['float64','float32','float16']).columns.values)
      print("non_categorical:",non_categorical)
      for nonCat in non_categorical:
          mean_val = np.nanmean(data[nonCat])
#          print("mean with NA:",np.mean(data[nonCat]))
#          print("median:",np.median(data[nonCat]))
#          print("median:",data[nonCat])
          #median_val = np.median(data[nonCat])
          if(np.isnan(mean_val) or np.isinf(mean_val)):
              mean_val = 0
              #np.around(mean_val, decimals=0)
          mean_val = round(mean_val, 2)
          print("mean_val:",mean_val," - column:",nonCat)
          data[nonCat].fillna(mean_val, inplace=True)

      print("Number of rows in data [After Data Cleaning - But converting NAN/INF]:", data.shape[0])

      y = data.HasDetections 
      X=data[['SmartScreen',
                   'AVProductsInstalled',
                   'AVProductStatesIdentifier',
                   'AvSigVersion',
                   'EngineVersion',
                   'Census_TotalPhysicalRAM',
                   'Census_InternalPrimaryDiagonalDisplaySizeInInches',
                   'Census_PrimaryDiskTotalCapacity',
                   'Processor',
                   'Census_OSArchitecture',
                   'AppVersion',
                   'Census_SystemVolumeTotalCapacity',
                   'Census_IsAlwaysOnAlwaysConnectedCapable',
                   'Census_ProcessorCoreCount',
                   'Census_PowerPlatformRoleName',
                   'IsProtected',
#                   'Census_ProcessorModelIdentifier',
#                   'Census_IsVirtualDevice',
#                   'AVProductsEnabled',
#                   'Wdft_IsGamer',
#                   'Census_InternalPrimaryDisplayResolutionHorizontal',
#                   'RtpStateBitfield',
#                   'Census_ActivationChannel',
#                   'OsBuildLab',
#                   'Census_IsTouchEnabled',
#                   'Census_OSEdition',
#                   'Census_OSVersion',
#                   'Census_OSBuildRevision'
                   ]]
      
      X_train_main, X_test_final, y_train_main, y_test_final = train_test_split(X, y, test_size=0.20, random_state=42)
#      print(X.head())
      
      # Fit only to the training data
      self.scaler.fit(X_train_main)
#      kf = KFold(n_splits=2)
      
      # Now apply the transformations to the data: it should be for test and train
      X_train_main = self.scaler.transform(X_train_main)
      X_test_final = self.scaler.transform(X_test_final)
      
      #safety checks
      print("has any NAN in X_train:",np.any(np.isnan(X_train_main)))
      print("has any NAN in y_train:",np.any(np.isnan(y_train_main)))
      print("isFinite in X_Train:",np.all(np.isfinite(X_train_main)))
      print("isFinite in y_Train:",np.all(np.isfinite(y_train_main)))
      
#      print("kfold:",kf)
      # returns the number of splitting iterations in the cross-validator
#      kf.get_n_splits(X_train_main) 
#      KFold(n_splits=2, random_state=None, shuffle=False)
#      for train_index, test_index in kf.split(X_train_main): 
#          X_train, X_test = X_train_main[train_index], X_train_main[test_index]
#          y_train, y_test = y_train_main[train_index], y_train_main[test_index]
#          print("has any NAN in X_train:",np.any(np.isnan(X_train)))
#          print("has any NAN in X_train:",np.any(np.isnan(y_train)))
#          print("isFinite in X_Train:",np.all(np.isfinite(X_train)))
#          print("isFinite in X_Train:",np.all(np.isfinite(y_train)))
      #--------------
#      self.mlp.fit(X_train_main,y_train_main)
      #create model
     
    
    #get number of columns in training data
      n_cols = X_train_main.shape[1]
     
      #Neural Net------------
      #add model layers
#      self.model.add(Dense(250, activation='relu', input_shape=(n_cols,)))
#      self.model.add(Dense(250, activation='relu'))
#      self.model.add(Dense(250, activation='relu'))
#      self.model.add(Dense(1, activation='softmax'))
      
      #compile model using mse as a measure of model performance
#      self.model.compile(optimizer='adam', loss='mean_squared_error')
       
#      early_stopping_monitor = EarlyStopping(patience=3)
      
      #train model
#      history = self.model.fit(X_train_main, y_train_main, validation_split=0.2, epochs=3, callbacks=[early_stopping_monitor])
#      print("symmary:",self.model.summary())
      #Neural Net------------
      
#          print("finished ",train_index, " round")
      self.clf.fit(X_train_main,y_train_main)
      print("--------------------------------- Start predict on sample data---------------------------------")
#      print("KERAS Neural Net - Test-Accuracy:", np.mean(history.history["val_acc"]))
      #predict on sample data
#      predictions = self.mlp.predict(X_test_final)
      predictions = self.clf.predict(X_test_final)
      print(confusion_matrix(y_test_final,predictions))
      print(classification_report(y_test_final,predictions))
     
        #Neural Net------------
#      test_y_predictions = self.model.predict(X_test_final)
#      print(confusion_matrix(y_test_final,test_y_predictions))
#      #Neural Net------------
      print("--------------------------------- End of predict on sample data---------------------------------")

 
      
      # TODO adjust later to replace the categories with proper int or float numbers
#      X = data.drop('HasDetections', axis=1)
           # TODO cleanup the code 
      
##      X = X.dropna(subset=['Wdft_RegionIdentifier', 'Census_IsPenCapable'])
#      print('X:',X)
#      #print('y:',y)
#      X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1)
#      
#      self.clf.fit(X, y)
      

  #predicts the probablity of a machine affected by malware. The input test_data is a pandas dataframe.
  #This function must return the predicted probabilities for the test machines
    def predict_probablities(self, test_data):
      print("--------------------------------- Start predict on TEST data---------------------------------")
      test_data=test_data[['SmartScreen',
                   'AVProductsInstalled',
                   'AVProductStatesIdentifier',
                   'AvSigVersion',
                   'EngineVersion',
                   'Census_TotalPhysicalRAM',
                   'Census_InternalPrimaryDiagonalDisplaySizeInInches',
                   'Census_PrimaryDiskTotalCapacity',
                   'Processor',
                   'Census_OSArchitecture',
                   'AppVersion',
                   'Census_SystemVolumeTotalCapacity',
                   'Census_IsAlwaysOnAlwaysConnectedCapable',
                   'Census_ProcessorCoreCount',
                   'Census_PowerPlatformRoleName',
                   'IsProtected',
#                   'Census_ProcessorModelIdentifier',
#                   'Census_IsVirtualDevice',
#                   'AVProductsEnabled',
#                   'Wdft_IsGamer',
#                   'Census_InternalPrimaryDisplayResolutionHorizontal',
#                   'RtpStateBitfield',
#                   'Census_ActivationChannel',
#                   'OsBuildLab',
#                   'Census_IsTouchEnabled',
#                   'Census_OSEdition',
#                   'Census_OSVersion',
#                   'Census_OSBuildRevision'
                   ]] 
      
#      y_test = test_data.HasDetections
#      test_data = test_data.drop('HasDetections', axis=1)
      
      print("handling categorical data in test_data with shape:",test_data.shape)
#      test_data = self.handleCategoricalData(test_data)
      categorical = list(test_data.select_dtypes(include=['object']).columns.values)
      print("captured categorical columns:",categorical)
      for category in categorical:
          test_data[category].fillna("NA", inplace=True)
          test_data[category] = [x.replace('.', '') for x in test_data[category]]
          #handling fields with combined String + float
          test_data[category] = self.labelEncoder.fit_transform(test_data[category].astype(str))
          
      non_categorical = list(test_data.select_dtypes(include=['float64','float32','float16']).columns.values)
      print("captured non_categorical columns:",non_categorical)
      for nonCat in non_categorical:
          mean_val = np.mean(test_data[nonCat])
          #median_val = np.median(data[nonCat])
          if(np.isnan(mean_val)):
              mean_val = 0
          mean_val = round(mean_val, 2)
          #filling NAN fields with MEAN value of the column
          print("mean_val:",mean_val," - column:",nonCat)
          test_data[nonCat].fillna(mean_val, inplace=True)
          
          
      test_data = self.scaler.transform(test_data)   
      #TODO Adjusting the return type shape
#      predictions = self.clf.predict_proba(test_data)[:, 1]
#      print("Accuracy: %.2f" % accuracy_score(y_test,y_pred))
#      predictions = self.clf.predict_proba(test_data)[:, 1]
      predictions = self.clf.predict(test_data)
#      fpr, tpr, thresholds = roc_curve(y_test, y_prob[:, 1], pos_label=4, drop_intermediate='False')
#      roc_auc = auc(fpr, tpr)
#      print("AUC: %.2f" % roc_auc)

      #---------random above forest -------
#      predictions = self.mlp.predict(test_data)
#      print("predictions:",predictions)    
      #Neural Net------------
#      predictions = self.model.predict(test_data)

#      print(confusion_matrix(test_data,predictions))
#      print(classification_report(test_data,predictions))
      print("--------------------------------- End of predict on TEST data---------------------------------")
      return predictions
 

#calls the train function and saves the model_file
#donot modify the contents
if __name__ == "__main__":
    detectionModel = MalwareDetectionModel()
    detectionModel.train()
    filename = 'malwaremodel.pkl'
    f = open(filename, 'wb')
    dill.dump(detectionModel, f)
    f.close()
