def warn(*args, **kwargs):
    pass
import warnings
warnings.warn = warn

import warnings
import datetime
import pandas as pd
import pickle
import dill
from sklearn.model_selection import train_test_split
from sklearn import tree
from sklearn.metrics import accuracy_score
from sklearn.metrics import auc, roc_curve
import sys 
#import dask.dataframe as dd
from sklearn import preprocessing 
#dta normalization tool
from sklearn.preprocessing import StandardScaler
# Neural Network api
#from sklearn.neural_network import MLPClassifier
from sklearn.ensemble import RandomForestClassifier
#from sklearn import svm

from sklearn.ensemble import AdaBoostClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score
# metrics
from sklearn.metrics import classification_report,confusion_matrix
#from sklearn.feature_extraction import DictVectorizer
#from sklearn.model_selection import KFold
from sklearn.model_selection import StratifiedKFold
#from xgboost import XGBClassifier
import xgboost as xgb
import numpy as np
#Donot modify the method signatures and return dtypes
#you can include additional functions of your choice


class MalwareDetectionModel:
    
    
    def __init__(self):
       self.dtypes = {
               'MachineIdentifier':                                     'category', # Not Required in Classification
               'ProductName':                                           'object', # Required in Classification
                'EngineVersion':                                        'object', # Required in Classification
                'AppVersion':                                           'object', # Required in Classification
                'AvSigVersion':                                         'object', # Required in Classification
                'IsBeta':                                               'float16', 
                'RtpStateBitfield':                                     'float64',
                'IsSxsPassiveMode':                                     'float16',
                'DefaultBrowsersIdentifier':                            'float64',
                'AVProductStatesIdentifier':                            'float64',
                'AVProductsInstalled':                                  'float64',
                'AVProductsEnabled':                                    'float64',
                'HasTpm':                                               'float64',
                'CountryIdentifier':                                    'float64',
                'CityIdentifier':                                       'float64',
                'OrganizationIdentifier':                               'float64',
                'GeoNameIdentifier':                                    'float64',
                'LocaleEnglishNameIdentifier':                          'float64',
                'Platform':                                             'object',
                'Processor':                                            'object',
                'OsVer':                                                'object',
                'OsBuild':                                              'float64',
                'OsSuite':                                              'float64',
                'OsPlatformSubRelease':                                 'object',
                'OsBuildLab':                                           'object',
                'SkuEdition':                                           'object',
                'IsProtected':                                          'float16',
                'AutoSampleOptIn':                                      'float64',
                'PuaMode':                                              'object',
                'SMode':                                                'float64',
                'IeVerIdentifier':                                      'float64',
                'SmartScreen':                                          'object',
                'Firewall':                                             'float64',
                'UacLuaenable':                                         'float64',
                'Census_MDC2FormFactor':                                'object',
                'Census_DeviceFamily':                                  'object',
                'Census_OEMNameIdentifier':                             'float64',
                'Census_OEMModelIdentifier':                            'float64',
                'Census_ProcessorCoreCount':                            'float64',
                'Census_ProcessorManufacturerIdentifier':               'float64',
                'Census_ProcessorModelIdentifier':                      'float64',
                'Census_ProcessorClass':                                'object',
                'Census_PrimaryDiskTotalCapacity':                      'float64',
                'Census_PrimaryDiskTypeName':                           'object',
                'Census_SystemVolumeTotalCapacity':                     'float64',
                'Census_HasOpticalDiskDrive':                           'float64',
                'Census_TotalPhysicalRAM':                              'float64',
                'Census_ChassisTypeName':                               'object',
                'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float64',
                'Census_InternalPrimaryDisplayResolutionHorizontal':    'float64',
                'Census_InternalPrimaryDisplayResolutionVertical':      'float64',
                'Census_PowerPlatformRoleName':                         'object',
                'Census_InternalBatteryType':                           'object',
                'Census_InternalBatteryNumberOfCharges':                'float64',
                'Census_OSVersion':                                     'object',
                'Census_OSArchitecture':                                'object',
                'Census_OSBranch':                                      'object',
                'Census_OSBuildNumber':                                 'float64',
                'Census_OSBuildRevision':                               'float64',
                'Census_OSEdition':                                     'object',
                'Census_OSSkuName':                                     'object',
                'Census_OSInstallTypeName':                             'object',
                'Census_OSInstallLanguageIdentifier':                   'float64',
                'Census_OSUILocaleIdentifier':                          'float64',
                'Census_OSWUAutoUpdateOptionsName':                     'object',
                'Census_IsPortableOperatingSystem':                     'float16',
                'Census_GenuineStateName':                              'object',
                'Census_ActivationChannel':                             'object',
                'Census_IsFlightingInternal':                           'float16',
                'Census_IsFlightsDisabled':                             'float16',
                'Census_FlightRing':                                    'object',
                'Census_ThresholdOptIn':                                'float64',
                'Census_FirmwareManufacturerIdentifier':                'float64',
                'Census_FirmwareVersionIdentifier':                     'float64',
                'Census_IsSecureBootEnabled':                           'float16',
                'Census_IsWIMBootEnabled':                              'float16',
                'Census_IsVirtualDevice':                               'float16',
                'Census_IsTouchEnabled':                                'float16',
                'Census_IsPenCapable':                                  'float16',
                'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',
                'Wdft_IsGamer':                                         'float64',
                'Wdft_RegionIdentifier':                                'float64',
               #fill in the data types for the rest of the columns
                'HasDetections':                                        'int8'
               }
       
          

       self.clf = RandomForestClassifier(n_estimators=15, max_depth=2,bootstrap=True)
              #define the model in class level so all the methods can use it.
 
#       self.mlp = MLPClassifier(hidden_layer_sizes=(13,13,13),max_iter=500)# I tried with 500 on test data
       self.xgboost = xgb.XGBClassifier(max_depth=10, learning_rate=0.1, n_estimators=20, nthread=50)
#       self.xgboost = xgb.XGBRegressor(objective='binary:logistic', colsample_bytree = 0.3, learning_rate = 0.1,
#                max_depth=4, alpha=15, n_estimators=10, nthread=10)
       self.mlp = AdaBoostClassifier(DecisionTreeClassifier(max_depth=2),algorithm="SAMME",learning_rate=1,n_estimators=50)
#       self.clf2 = svm.SVC(gamma=0.001, C=100.)
       self.clf2 = RandomForestClassifier(n_estimators=10, max_depth=3,bootstrap=False)
       self.labelEncoder = preprocessing.LabelEncoder()
       #standardization of data -- similar process for normalizaition
       self.scaler = StandardScaler()
       
       self.important_attributes = ['SmartScreen',
                   'AVProductsInstalled',
                   'AVProductStatesIdentifier',
                   'AvSigVersion',
                   'EngineVersion',
                   'Census_TotalPhysicalRAM',
                   'Census_InternalPrimaryDiagonalDisplaySizeInInches',
                   'Census_PrimaryDiskTotalCapacity',
                   'Processor',
                   'Census_OSArchitecture',
                   'AppVersion',
                   'Census_SystemVolumeTotalCapacity',
                   'Census_IsAlwaysOnAlwaysConnectedCapable',
                   'Census_ProcessorCoreCount',
                   'Census_PowerPlatformRoleName',
                   'IsProtected',
                   'Census_ProcessorModelIdentifier',
                   'Census_IsVirtualDevice',
                   'AVProductsEnabled',
                   'Wdft_IsGamer',
#                   'Census_InternalPrimaryDisplayResolutionHorizontal',
#                   'RtpStateBitfield',
#                   'Census_ActivationChannel',
#                   'OsBuildLab',
#                   'Census_IsTouchEnabled',
#                   'Census_OSEdition',
#                   'Census_OSVersion',
#                   'Census_OSBuildRevision',
                   'HasDetections']
       
       self.important_attributes_StackedProcessed_wihtout_hasDetections = ['SmartScreen',
                   'AVProductsInstalled',
                   'AVProductStatesIdentifier',
                   'AvSigVersion',
                   'EngineVersion',
                   'Census_TotalPhysicalRAM',
                   'Census_InternalPrimaryDiagonalDisplaySizeInInches',
                   'Census_PrimaryDiskTotalCapacity',
                   'Processor',
                   'Census_OSArchitecture',
                   'AppVersion',
                   'Census_SystemVolumeTotalCapacity',
                   'Census_IsAlwaysOnAlwaysConnectedCapable',
                   'Census_ProcessorCoreCount',
                   'Census_PowerPlatformRoleName',
                   'IsProtected',
                   'Census_ProcessorModelIdentifier',
                   'Census_IsVirtualDevice',
                   'AVProductsEnabled',
                   'Wdft_IsGamer',
#                   'Census_InternalPrimaryDisplayResolutionHorizontal',
#                   'RtpStateBitfield',
#                   'Census_ActivationChannel',
#                   'OsBuildLab',
#                   'Census_IsTouchEnabled',
#                   'Census_OSEdition',
#                   'Census_OSVersion',
#                   'Census_OSBuildRevision',
                   'HasDetections_predictedModeled1',
                   'HasDetections_predictedModeled2']
  
       self.important_attributes_wihtout_hasDetections = ['SmartScreen',
                   'AVProductsInstalled',
                   'AVProductStatesIdentifier',
                   'AvSigVersion',
                   'EngineVersion',
                   'Census_TotalPhysicalRAM',
                   'Census_InternalPrimaryDiagonalDisplaySizeInInches',
                   'Census_PrimaryDiskTotalCapacity',
                   'Processor',
                   'Census_OSArchitecture',
                   'AppVersion',
                   'Census_SystemVolumeTotalCapacity',
                   'Census_IsAlwaysOnAlwaysConnectedCapable',
                   'Census_ProcessorCoreCount',
                   'Census_PowerPlatformRoleName',
                   'IsProtected',
                   'Census_ProcessorModelIdentifier',
                   'Census_IsVirtualDevice',
                   'AVProductsEnabled',
                   'Wdft_IsGamer',
#                   'Census_InternalPrimaryDisplayResolutionHorizontal',
#                   'RtpStateBitfield',
#                   'Census_ActivationChannel',
#                   'OsBuildLab',
#                   'Census_IsTouchEnabled',
#                   'Census_OSEdition',
#                   'Census_OSVersion',
#                   'Census_OSBuildRevision'
                   ]
      
      
  #trains a model, you can access the malware_train.csv file for training your model
    def train(self):
      print("------ Start of training on sample data --------")
      print("Started Cleanup:",str(datetime.datetime.now()))
      fileName = sys.argv[1]
      data = pd.read_csv(fileName, dtype=self.dtypes)
      
      #drop only when everything is NAN
      data = data.dropna(how='all')
      data = data[self.important_attributes]
      
      data.replace([np.inf, -np.inf], np.nan)
      
      print("Number of rows in data [Before Data Cleaning - But converting NAN/INF]:", data.shape[0])
      print("Ending Cleanup At:",str(datetime.datetime.now()))
      print("Starting Convertion at:",str(datetime.datetime.now()))
      categorical = list(data.select_dtypes(include=['object']).columns.values)
#      print("categorical:",categorical)
      for category in categorical:
          data[category].fillna("NA", inplace=True)
          data[category] = [x.replace('.', '') for x in data[category]]
          #handling fields with combined String + float
          data[category] = self.labelEncoder.fit_transform(data[category].astype(str))
          
      non_categorical = list(data.select_dtypes(include=['float64','float32','float16']).columns.values)
#      print("non_categorical:",non_categorical)
      for nonCat in non_categorical:
          mean_val = np.nanmean(data[nonCat])
          if(np.isnan(mean_val) or np.isinf(mean_val)):
              mean_val = 0
              #np.around(mean_val, decimals=0)
          mean_val = round(mean_val, 2)
#          print("mean_val:",mean_val," - column:",nonCat)
          data[nonCat].fillna(mean_val, inplace=True)

#      print("Number of rows in data [After Data Cleaning - But converting NAN/INF]:", data.shape[0])

      data['HasDetections_predictedModeled1']  = 0
      data['HasDetections_predictedModeled2']  = 0
    
      #splitting main TRAIN and TEST data
      num_records = 10 
      X_test_final = data[:num_records]
      y_test_final = X_test_final['HasDetections']
      # drop the column from x test
      X_test_final = X_test_final.drop('HasDetections',axis=1)
      
      #delete rows which I selected above
      X_train_main = data.drop(data.index[:num_records],axis=0)
      y_train_main = X_train_main['HasDetections']
      X_train_main = X_train_main.drop('HasDetections',axis=1)
      
      
      #scale data 
      self.scaler.fit(X_train_main)
      # Now apply the transformations to the data: it should be for test and train
      X_train_main = self.scaler.transform(X_train_main)
      X_train_main = pd.DataFrame(X_train_main, columns = self.important_attributes_StackedProcessed_wihtout_hasDetections)
      X_test_final = self.scaler.transform(X_test_final)
      X_test_final = pd.DataFrame(X_test_final, columns = self.important_attributes_StackedProcessed_wihtout_hasDetections)
      
      #rebuild and reset index
      
#      X_train_main['HasDetections_predictedModeled1']  = 0
#      X_train_main['HasDetections_predictedModeled2']  = 0
#      X_test_final['HasDetections_predictedModeled1']  = 0
#      X_test_final['HasDetections_predictedModeled2']  = 0
    
    
      X_train_main.reset_index(drop=True, inplace=True)
      y_train_main.reset_index(drop=True, inplace=True)
#      print("Number of rows in data [After Data Cleaning - But converting NAN/INF]:", data.shape[0])
      
      
      #safety checks
#      print("has any NAN in X_train:",np.any(np.isnan(X_train_main)))
#      print("has any NAN in y_train:",np.any(np.isnan(y_train_main)))
#      print("isFinite in X_Train:",np.all(np.isfinite(X_train_main)))
#      print("isFinite in y_Train:",np.all(np.isfinite(y_train_main)))
 
      # returns the number of splitting iterations in the cross-validator
      
      skf = StratifiedKFold(n_splits=5)
      skf.get_n_splits(X_train_main, y_train_main)
#      print(skf) 
      print("Finishing Convertion at:",str(datetime.datetime.now()))
      print("STACK LAYER #1: First Classifier (RandomForests) in STACK is processing ... ")
      print("Start Modeling with model 1:",str(datetime.datetime.now()))
#      self.clf.fit(X_train_main,y_train_main)
#      predictions = self.clf.predict(X_test_final)
#      print("Accuracy M1: %.2f%%" % (accuracy_score(y_test_final, predictions) * 100.0))      
#      X_train_main['HasDetections_predictedModeled1'] = predictions
      for train_index, test_index in skf.split(X_train_main, y_train_main): 
#          print("trainIndex:", train_index , "\ntestIndex:",test_index)
          
          X_train_model1= X_train_main.loc[train_index]
          y_train_model1 = y_train_main.loc[train_index]
          
          X_test_model1 = X_train_main.loc[test_index]
          y_test_model1 = y_train_main.loc[test_index]
      
#          print("has any NAN in X_train_model1:",np.any(np.isnan(X_train_model1)))
#          print("has any NAN in X_test_model1:",np.any(np.isnan(X_test_model1)))
#          print("isFinite in X_train_model1:",np.all(np.isfinite(X_train_model1)))
#          print("isFinite in X_test_model1:",np.all(np.isfinite(X_test_model1)))
#          print("has any NAN in y_train_model1:",np.any(np.isnan(y_train_model1)))
#          print("isFinite in y_train_model1:",np.all(np.isfinite(y_train_model1)))
          
          self.clf.fit(X_train_model1,y_train_model1)
          predictions = self.clf.predict(X_test_model1)
          print("Accuracy M1: %.2f%%" % (accuracy_score(y_test_model1, predictions) * 100.0))      
          #save result of one perdiction as a new feature
          prediction_iterator = 0
          for index_pointer in test_index:
              X_train_main.loc[X_train_main.index[index_pointer], 'HasDetections_predictedModeled1'] = predictions[prediction_iterator]
              prediction_iterator = prediction_iterator+1

#      print("1st Round result:\n", confusion_matrix(predictions,y_test_model1))
#      print(classification_report(y_test_model1,predictions))
      print("Finished Modeling with model 1:",str(datetime.datetime.now()))
      print("STACK LAYER #1: First Classifier (RandomForests) in STACK is Finished successfully.")
      print("STACK LAYER #2: Second Classifier (Neural Network) in STACK is processing ... ")
      print("Start Modeling with model 2:",str(datetime.datetime.now()))
#      self.mlp.fit(X_train_main,y_train_main)
#      predictions = self.mlp.predict(X_test_final)
#      print("Accuracy M2: %.2f%%" % (accuracy_score(y_test_final, predictions) * 100.0))
#      X_train_main['HasDetections_predictedModeled2'] = predictions
      for train_index, test_index in skf.split(X_train_main, y_train_main): 
#          print("trainIndex:", train_index , "\ntestIndex:",test_index)
          
          X_train_model1= X_train_main.loc[train_index]
          y_train_model1 = y_train_main.loc[train_index]
          
          X_test_model1 = X_train_main.loc[test_index]
          y_test_model1 = y_train_main.loc[test_index]
      
#          print("has any NAN in X_train_model1:",np.any(np.isnan(X_train_model1)))
#          print("has any NAN in X_test_model1:",np.any(np.isnan(X_test_model1)))
#          print("isFinite in X_train_model1:",np.all(np.isfinite(X_train_model1)))
#          print("isFinite in X_test_model1:",np.all(np.isfinite(X_test_model1)))
#          print("has any NAN in y_train_model1:",np.any(np.isnan(y_train_model1)))
#          print("isFinite in y_train_model1:",np.all(np.isfinite(y_train_model1)))
          
          self.mlp.fit(X_train_model1,y_train_model1)
          predictions = self.mlp.predict(X_test_model1)
          print("Accuracy M2: %.2f%%" % (accuracy_score(y_test_model1, predictions) * 100.0))
          #save result of one perdiction as a new feature
          prediction_iterator = 0
          for index_pointer in test_index:
              X_train_main.loc[X_train_main.index[index_pointer], 'HasDetections_predictedModeled2'] = predictions[prediction_iterator]
              prediction_iterator = prediction_iterator+1

#      print("2nd Rount result:\n", confusion_matrix(predictions,y_test_model1))
#      print(classification_report(y_test_model1,predictions))
      print("Finish Modeling with model 2:",str(datetime.datetime.now()))
      print("STACK LAYER #2: Second Classifier (Neural Network) in STACK is finished successfully.")
      print("STACK LAYER #3: Third Classifier (SVM) in STACK is processing ... ")
      print("Start Modeling with model 3:",str(datetime.datetime.now()))
#      weight = float(len(y_train_main[y_train_main == 0]))/float(len(y_train_main[y_train_main == 1]))
      weights1 = np.array([1]*y_train_main.shape[0])
#      weights[y_train_model1==1]=weight
      weights1[X_train_main['HasDetections_predictedModeled1']==1]=1
      weights1[X_train_main['HasDetections_predictedModeled1']==0]=1
      
      weights2 = np.array([1]*y_train_main.shape[0]) 
      weights2[X_train_main['HasDetections_predictedModeled2']==1]=1
      weights2[X_train_main['HasDetections_predictedModeled2']==0]=1
      
      weights = np.array([1]*y_train_main.shape[0])
       
      for index in range(weights1.shape[0]):
          if(weights2[index] == weights1[index]):
              weights[index]=1
      
      self.xgboost.fit(X_train_main,y_train_main,weights)
      predictions2 = self.xgboost.predict(X_test_final)
      predictions = [round(value) for value in predictions2]
      print("Accuracy M3: %.2f%%" % (accuracy_score(y_test_final, predictions) * 100.0))
#      skf = StratifiedKFold(n_splits=2)
#      skf.get_n_splits(X_train_main, y_train_main)
#      for train_index, test_index in skf.split(X_train_main, y_train_main): 
#
#          X_train_model1 = X_train_main.loc[train_index]
#          y_train_model1 = y_train_main.loc[train_index]
#          
#          X_test_model1 = X_train_main.loc[test_index]
#          y_test_model1 = y_train_main.loc[test_index]
#          
#          weight = float(len(y_train_model1[y_train_model1 == 0]))/float(len(y_train_model1[y_train_model1 == 1]))
#          weights = np.array([1]*y_train_model1.shape[0])
#          weights[y_train_model1==1]=weight
#          weights[X_train_model1['HasDetections_predictedModeled1']==1]=1
###          self.clf2.fit(X_train_model1,y_train_model1)
#          self.xgboost.fit(X_train_model1,y_train_model1,weights)
#          predictions2 = self.xgboost.predict(X_test_model1)
#          predictions = [round(value) for value in predictions2]
#          print("Accuracy M3: %.2f%%" % (accuracy_score(y_test_model1, predictions) * 100.0))
#          
#      predictions = self.clf2.predict(X_test_final)
      print("Finish Modeling with model 3:",str(datetime.datetime.now()))
      print("STACK LAYER #3: Third Classifier (SVM) in STACK is finished successfully.")
#      print("final result:\n", confusion_matrix(y_test_final,predictions))
#      print(classification_report(y_test_final,predictions))
      print ("Finiahed At:",str(datetime.datetime.now()))
      print("------ End of training on sample data --------")

 
  #predicts the probablity of a machine affected by malware. The input test_data is a pandas dataframe.
  #This function must return the predicted probabilities for the test machines
    def predict_probablities(self, test_data):
        print("--------------------------------- Start predict on TEST data---------------------------------")
        test_data=test_data[self.important_attributes_wihtout_hasDetections] 
        test_data.replace([np.inf, -np.inf], np.nan)
        print("Number of rows in data [Before Data Cleaning - But converting NAN/INF]:", test_data.shape[0])
        categorical = list(test_data.select_dtypes(include=['object']).columns.values)

        for category in categorical:
            test_data[category].fillna("NA", inplace=True)
            test_data[category] = [x.replace('.', '') for x in test_data[category]]
            #handling fields with combined String + float
            test_data[category] = self.labelEncoder.fit_transform(test_data[category].astype(str))
          
        non_categorical = list(test_data.select_dtypes(include=['float64','float32','float16']).columns.values)
        for nonCat in non_categorical:
            mean_val = np.nanmean(test_data[nonCat])
            if(np.isnan(mean_val) or np.isinf(mean_val)):
                mean_val = 0
            mean_val = round(mean_val, 2)
            test_data[nonCat].fillna(mean_val, inplace=True)
            
        
        test_data['HasDetections_predictedModeled1']  = 0
        test_data['HasDetections_predictedModeled2']  = 0
        test_data = self.scaler.transform(test_data)   
        test_data = pd.DataFrame(test_data, columns = self.important_attributes_StackedProcessed_wihtout_hasDetections)
        test_data['HasDetections_predictedModeled1']  = 0
        test_data['HasDetections_predictedModeled2']  = 0
        test_data_dim = test_data.shape[0]
        print("test data dim:",test_data_dim)

        predictions = self.clf.predict(test_data) 
        prediction_iterator = 0
        index_pointer = 0
        while index_pointer < test_data_dim:
            test_data.loc[test_data.index[index_pointer], 'HasDetections_predictedModeled1'] = predictions[prediction_iterator]
            prediction_iterator = prediction_iterator+1
            index_pointer = index_pointer+1
        print("finished populating predicted result in M1.")
#        
        predictions = self.mlp.predict(test_data) 
        prediction_iterator = 0
        index_pointer = 0
        while index_pointer < test_data_dim:
            test_data.loc[test_data.index[index_pointer], 'HasDetections_predictedModeled2'] = predictions[prediction_iterator]
            prediction_iterator = prediction_iterator+1
            index_pointer = index_pointer+1
        print("finished populating predicted result in M2.")
        
#        predictions = self.clf2.predict(test_data) 
        predictions = self.xgboost.predict(test_data)
        predictions = [round(value) for value in predictions]
        print("finished populating predicted result in Final level of Stack.")
        
        print("--------------------------------- End of predict on TEST data---------------------------------")
        return predictions
 

#calls the train function and saves the model_file
#donot modify the contents
if __name__ == "__main__":
    detectionModel = MalwareDetectionModel()
    detectionModel.train()
    filename = 'malwaremodel.pkl'
    f = open(filename, 'wb')
    dill.dump(detectionModel, f)
    f.close()
