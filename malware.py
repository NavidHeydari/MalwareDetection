import warnings
import numpy as np
import pandas as pd
import pickle
import dill
from sklearn.model_selection import train_test_split
from sklearn import tree
from sklearn.metrics import accuracy_score
from sklearn.metrics import auc, roc_curve
import sys 

#Donot modify the method signatures and return dtypes
#you can include additional functions of your choice


class MalwareDetectionModel:
  def __init__(self):
       self.dtypes = {
               'MachineIdentifier':                                    'category',
               'ProductName':  'category',
                'EngineVersion': 'category',
                'AppVersion': 'category',
                'AvSigVersion': 'category',
                'IsBeta': 'int8',
                'RtpStateBitfield': 'int8',
                'IsSxsPassiveMode': 'int8',
                'DefaultBrowsersIdentifier': 'int8',
                'AVProductStatesIdentifier': 'int8',
                'AVProductsInstalled': 'int8',
                'AVProductsEnabled': 'int8',
                'HasTpm': 'int8',
                'CountryIdentifier': 'int8',
                'CityIdentifier': 'int8',
                'OrganizationIdentifier': 'int8',
                'GeoNameIdentifier': 'int8',
                'LocaleEnglishNameIdentifier': 'int8',
                'Platform': 'category',
                'Processor': 'category',
                'OsVer': 'category',
                'OsBuild': 'int8',
                'OsSuite': 'int8',
                'OsPlatformSubRelease': 'category',
                'OsBuildLab': 'category',
                'SkuEdition': 'category',
                'IsProtected': 'int8',
                'AutoSampleOptIn': 'int8',
                'PuaMode': 'category',
                'SMode': 'int8',
                'IeVerIdentifier': 'int8',
                'SmartScreen': 'category',
                'Firewall': 'int8',
                'UacLuaenable': 'int8',
                'Census_MDC2FormFactor': 'category',
                'Census_DeviceFamily': 'category',
                'Census_OEMNameIdentifier': 'int8',
                'Census_OEMModelIdentifier': 'int8',
                'Census_ProcessorCoreCount': 'int8',
                'Census_ProcessorManufacturerIdentifier': 'int8',
                'Census_ProcessorModelIdentifier': 'int8',
                'Census_ProcessorClass': 'category',
                'Census_PrimaryDiskTotalCapacity': 'int8',
                'Census_PrimaryDiskTypeName': 'category',
                'Census_SystemVolumeTotalCapacity': 'int8',
                'Census_HasOpticalDiskDrive': 'int8',
                'Census_TotalPhysicalRAM': 'int8',
                'Census_ChassisTypeName': 'category',
                'Census_InternalPrimaryDiagonalDisplaySizeInInches': 'int8',
                'Census_InternalPrimaryDisplayResolutionHorizontal': 'int8',
                'Census_InternalPrimaryDisplayResolutionVertical': 'int8',
                'Census_PowerPlatformRoleName': 'category',
                'Census_InternalBatteryType': 'category',
                'Census_InternalBatteryNumberOfCharges': 'int8',
                'Census_OSVersion': 'category',
                'Census_OSArchitecture': 'category',
                'Census_OSBranch': 'category',
                'Census_OSBuildNumber': 'int8',
                'Census_OSBuildRevision': 'int8',
                'Census_OSEdition': 'category',
                'Census_OSSkuName': 'category',
                'Census_OSInstallTypeName': 'category',
                'Census_OSInstallLanguageIdentifier': 'int8',
                'Census_OSUILocaleIdentifier': 'int8',
                'Census_OSWUAutoUpdateOptionsName': 'category',
                'Census_IsPortableOperatingSystem': 'int8',
                'Census_GenuineStateName': 'category',
                'Census_ActivationChannel': 'category',
                'Census_IsFlightingInternal': 'int8',
                'Census_IsFlightsDisabled': 'int8',
                'Census_FlightRing': 'category',
                'Census_ThresholdOptIn': 'int8',
                'Census_FirmwareManufacturerIdentifier': 'int8',
                'Census_FirmwareVersionIdentifier': 'int8',
                'Census_IsSecureBootEnabled': 'int8',
                'Census_IsWIMBootEnabled': 'int8',
                'Census_IsVirtualDevice': 'int8',
                'Census_IsTouchEnabled': 'int8',
                'Census_IsPenCapable': 'int8',
                'Census_IsAlwaysOnAlwaysConnectedCapable': 'int8',
                'Wdft_IsGamer': 'int8',
                'Wdft_RegionIdentifier': 'int8',
               #fill in the data types for the rest of the columns
               'HasDetections':                                        'int8'
               }


  #trains a model, you can access the malware_train.csv file for training your model
  def train(self):
      fileName = sys.argv[1]

      data = pd.read_csv(fileName, index_col=0)
      #print(data.head())
#      print("Number of rows in data:", data.shape[0])
#      print(data.head())
      # Training and testing a decision tree
      y = data.HasDetections
      X = data.drop('HasDetections', axis=1)
      #print('X:',X)
      #print('y:',y)
      X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1)
      clf = tree.DecisionTreeClassifier(max_depth=5)
      clf.fit(X_train, y_train)
      

  #predicts the probablity of a machine affected by malware. The input test_data is a pandas dataframe.
  #This function must return the predicted probabilities for the test machines
  def predict_probablities(self, test_data):

      print('Predict malware')
#      clf = tree.DecisionTreeClassifier(max_depth=3)
#      clf.fit(X_train, y_train)
#      y_pred = clf.predict(X_test)
#      print("WITHOUT STRATIFICATION")
#      print("Accuracy: %.2f" % accuracy_score(y_test,y_pred))
      y_prob = clf.predict_proba(test_data)
      predictions = y_prob
      return predictions


#calls the train function and saves the model_file
#donot modify the contents
if __name__ == "__main__":
    detectionModel = MalwareDetectionModel()
    detectionModel.train()
    filename = 'malwaremodel.pkl'
    f = open(filename, 'wb')
    dill.dump(detectionModel, f)
    f.close()
