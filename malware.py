def warn(*args, **kwargs):
    pass
import warnings
warnings.warn = warn

import warnings
import numpy as np
import pandas as pd
import pickle
import dill
from sklearn.model_selection import train_test_split
from sklearn import tree
from sklearn.metrics import accuracy_score
from sklearn.metrics import auc, roc_curve
import sys 
import dask.dataframe as dd
from sklearn import preprocessing 
#dta normalization tool
from sklearn.preprocessing import StandardScaler
# Neural Network api
from sklearn.neural_network import MLPClassifier
# metrics
from sklearn.metrics import classification_report,confusion_matrix
from sklearn.feature_extraction import DictVectorizer


#Donot modify the method signatures and return dtypes
#you can include additional functions of your choice


class MalwareDetectionModel:
  def __init__(self):
       self.dtypes = {
               'MachineIdentifier':                                     'category', # Not Required in Classification
               'ProductName':                                           'object', # Required in Classification
                'EngineVersion':                                        'object', # Required in Classification
                'AppVersion':                                           'object', # Required in Classification
                'AvSigVersion':                                         'object', # Required in Classification
                'IsBeta':                                               'float16', 
                'RtpStateBitfield':                                     'float64',
                'IsSxsPassiveMode':                                     'float16',
                'DefaultBrowsersIdentifier':                            'float64',
                'AVProductStatesIdentifier':                            'float64',
                'AVProductsInstalled':                                  'float64',
                'AVProductsEnabled':                                    'float64',
                'HasTpm':                                               'float64',
                'CountryIdentifier':                                    'float64',
                'CityIdentifier':                                       'float64',
                'OrganizationIdentifier':                               'float64',
                'GeoNameIdentifier':                                    'float64',
                'LocaleEnglishNameIdentifier':                          'float64',
                'Platform':                                             'object',
                'Processor':                                            'object',
                'OsVer':                                                'object',
                'OsBuild':                                              'float64',
                'OsSuite':                                              'float64',
                'OsPlatformSubRelease':                                 'object',
                'OsBuildLab':                                           'object',
                'SkuEdition':                                           'object',
                'IsProtected':                                          'float16',
                'AutoSampleOptIn':                                      'float64',
                'PuaMode':                                              'object',
                'SMode':                                                'float64',
                'IeVerIdentifier':                                      'float64',
                'SmartScreen':                                          'object',
                'Firewall':                                             'float64',
                'UacLuaenable':                                         'float64',
                'Census_MDC2FormFactor':                                'object',
                'Census_DeviceFamily':                                  'object',
                'Census_OEMNameIdentifier':                             'float64',
                'Census_OEMModelIdentifier':                            'float64',
                'Census_ProcessorCoreCount':                            'float64',
                'Census_ProcessorManufacturerIdentifier':               'float64',
                'Census_ProcessorModelIdentifier':                      'float64',
                'Census_ProcessorClass':                                'object',
                'Census_PrimaryDiskTotalCapacity':                      'float64',
                'Census_PrimaryDiskTypeName':                           'object',
                'Census_SystemVolumeTotalCapacity':                     'float64',
                'Census_HasOpticalDiskDrive':                           'float64',
                'Census_TotalPhysicalRAM':                              'float64',
                'Census_ChassisTypeName':                               'object',
                'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float64',
                'Census_InternalPrimaryDisplayResolutionHorizontal':    'float64',
                'Census_InternalPrimaryDisplayResolutionVertical':      'float64',
                'Census_PowerPlatformRoleName':                         'object',
                'Census_InternalBatteryType':                           'object',
                'Census_InternalBatteryNumberOfCharges':                'float64',
                'Census_OSVersion':                                     'object',
                'Census_OSArchitecture':                                'object',
                'Census_OSBranch':                                      'object',
                'Census_OSBuildNumber':                                 'float64',
                'Census_OSBuildRevision':                               'float64',
                'Census_OSEdition':                                     'object',
                'Census_OSSkuName':                                     'object',
                'Census_OSInstallTypeName':                             'object',
                'Census_OSInstallLanguageIdentifier':                   'float64',
                'Census_OSUILocaleIdentifier':                          'float64',
                'Census_OSWUAutoUpdateOptionsName':                     'object',
                'Census_IsPortableOperatingSystem':                     'float16',
                'Census_GenuineStateName':                              'object',
                'Census_ActivationChannel':                             'object',
                'Census_IsFlightingInternal':                           'float16',
                'Census_IsFlightsDisabled':                             'float16',
                'Census_FlightRing':                                    'object',
                'Census_ThresholdOptIn':                                'float64',
                'Census_FirmwareManufacturerIdentifier':                'float64',
                'Census_FirmwareVersionIdentifier':                     'float64',
                'Census_IsSecureBootEnabled':                           'float16',
                'Census_IsWIMBootEnabled':                              'float16',
                'Census_IsVirtualDevice':                               'float16',
                'Census_IsTouchEnabled':                                'float16',
                'Census_IsPenCapable':                                  'float16',
                'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',
                'Wdft_IsGamer':                                         'float64',
                'Wdft_RegionIdentifier':                                'float64',
               #fill in the data types for the rest of the columns
                'HasDetections':                                        'int8'
               }
       
       #define the model in class level so all the methods can use it.
       self.clf = tree.DecisionTreeClassifier(max_depth=3)
       self.mlp = MLPClassifier(hidden_layer_sizes=(13,13,13),max_iter=500)# I tried with 500 on test data
       self.labelEncoder = preprocessing.LabelEncoder()
  
    
    
  def handleCategoricalData(self,data):
      #handling categorical data types columns
      vectorizer = DictVectorizer( sparse = False )
      categorical = list(data.select_dtypes(include=['object']).columns.values)
      print("categorical:",categorical)
      for category in categorical:
          data[category].fillna("NA", inplace=True)
          data[category] = [x.replace('.', '') for x in data[category]]
          #handling fields with combined String + float
          data[category] = self.labelEncoder.fit_transform(data[category].astype(str))
#          data[category] = vectorizer.fit_transform( data[category].astype(str))
          
      non_categorical = list(data.select_dtypes(include=['float64','float32','float16']).columns.values)
      print("non_categorical:",non_categorical)
      for nonCat in non_categorical:
          mean_val = np.mean(data[nonCat])
          #median_val = np.median(data[nonCat])
          if(np.isnan(mean_val)):
              mean_val = 0
              #np.around(mean_val, decimals=0)
          mean_val = round(mean_val, 2)
          print("mean_val:",mean_val," - column:",nonCat)
          data[nonCat].fillna(mean_val, inplace=True)
          
      return data
      
  #trains a model, you can access the malware_train.csv file for training your model
  def train(self):
      fileName = sys.argv[1]

    # TODO clean up the input file in details and analysis of the NAN and empty or similar values
      
#      df = pd.DataFrame()
#      for chunk in pd.read_csv(fileName, names=['id', 'text', 'code'], index_col=0, engine='python', chunksize=1000):
#          df = pd.concat([df, chunk], ignore_index=True)
#      data = dd.read_csv(fileName, dtype=self.dtypes)
      
    
      data = pd.read_csv(fileName, dtype=self.dtypes)
#      print(data.describe().transpose())
      

#      data = data.dropna(how='all')
#      data = data.dropna(subset=['SmartScreen','AvSigVersion','CityIdentifier','Census_SystemVolumeTotalCapacity','Census_FirmwareVersionIdentifier','Census_ProcessorModelIdentifier','Census_OEMModelIdentifier','CountryIdentifier','OrganizationIdentifier',
#                                 'Census_OSBuildRevision','GeoNameIdentifier','Census_OSVersion','Census_InternalPrimaryDiagonalDisplaySizeInInches',
#                                 'LocaleEnglishNameIdentifier','Census_OSInstallTypeName','Census_PrimaryDiskTotalCapacity','Census_TotalPhysicalRAM',
#                                 'AVProductStatesIdentifier','EngineVersion','Census_OEMNameIdentifier','Wdft_RegionIdentifier','AppVersion',
#                                 'Census_FirmwareManufacturerIdentifier','Census_OSInstallLanguageIdentifier','Census_OSUILocaleIdentifier',
#                                 #'Census_InternalPrimaryDisplayResolutionHorizontal','Census_ProcessorCoreCount','Census_InternalPrimaryDisplayResolutionVertical','AVProductsInstalled',
#                                 #'Census_OSWUAutoUpdateOptionsName','Census_InternalBatteryNumberOfCharges','Census_ChassisTypeName',
#                                 #'Census_InternalBatteryType','Census_ActivationChannel','IeVerIdentifier','OsBuildLab','Census_PrimaryDiskTypeName',
#                                 #'Wdft_IsGamer',
#                                 #'Census_IsSecureBootEnabled','Census_MDC2FormFactor','Census_OSBranch','Census_GenuineStateName',
#                                 #'Census_OSEdition','Census_OSSkuName','Census_ProcessorManufacturerIdentifier','Census_OSBuildNumber','Census_PowerPlatformRoleName',
#                                 #'OsBuild','Census_HasOpticalDiskDrive','OsPlatformSubRelease','Census_IsTouchEnabled','Census_FlightRing',
#                                 'HasDetections'])#'ProductName','EngineVersion','AppVersion','AvSigVersion','IsProtected','Census_IsAlwaysOnAlwaysConnectedCapable','Wdft_IsGamer','Wdft_RegionIdentifier', 'Census_IsPenCapable','HasDetections'])
    
      data = data[['SmartScreen','AvSigVersion','CityIdentifier','Census_SystemVolumeTotalCapacity','Census_FirmwareVersionIdentifier','Census_ProcessorModelIdentifier','Census_OEMModelIdentifier','CountryIdentifier','OrganizationIdentifier',
                                 'Census_OSBuildRevision','GeoNameIdentifier','Census_OSVersion','Census_InternalPrimaryDiagonalDisplaySizeInInches',
                                 'LocaleEnglishNameIdentifier','Census_OSInstallTypeName','Census_PrimaryDiskTotalCapacity','Census_TotalPhysicalRAM',
                                 'AVProductStatesIdentifier','EngineVersion','Census_OEMNameIdentifier','Wdft_RegionIdentifier','AppVersion',
                                 'Census_FirmwareManufacturerIdentifier','Census_OSInstallLanguageIdentifier','Census_OSUILocaleIdentifier',
                                 'Census_InternalPrimaryDisplayResolutionHorizontal','Census_ProcessorCoreCount','Census_InternalPrimaryDisplayResolutionVertical','AVProductsInstalled',
                                 'Census_OSWUAutoUpdateOptionsName','Census_InternalBatteryNumberOfCharges','Census_ChassisTypeName',
                                 'Census_InternalBatteryType','Census_ActivationChannel','IeVerIdentifier','OsBuildLab','Census_PrimaryDiskTypeName',
                                 'Wdft_IsGamer',
                                 #'Census_IsSecureBootEnabled','Census_MDC2FormFactor','Census_OSBranch','Census_GenuineStateName',
                                 #'Census_OSEdition','Census_OSSkuName','Census_ProcessorManufacturerIdentifier','Census_OSBuildNumber','Census_PowerPlatformRoleName',
                                 #'OsBuild','Census_HasOpticalDiskDrive','OsPlatformSubRelease','Census_IsTouchEnabled','Census_FlightRing',
                                 'HasDetections']]
    
      data.replace([np.inf, -np.inf], np.nan)
    
    
#      data = data.drop('MachineIdentifier',axis=1)
      print("Number of rows in data [Before Data Cleaning - But converting NAN/INF]:", data.shape[0])
      #convertng categories/Strings to numbers for classifications
#      data['ProductName'] = data['ProductName'].replace(self.map_to_int_col_2_ProductName)
#      data['EngineVersion'] = data['EngineVersion'].replace(self.map_to_int_col_3_EngineVersion)
      
#      data = self.handleCategoricalData(data)
      vectorizer = DictVectorizer( sparse = False )
      categorical = list(data.select_dtypes(include=['object']).columns.values)
      print("categorical:",categorical)
      for category in categorical:
          data[category].fillna("NA", inplace=True)
          data[category] = [x.replace('.', '') for x in data[category]]
          #handling fields with combined String + float
          data[category] = self.labelEncoder.fit_transform(data[category].astype(str))
          
      non_categorical = list(data.select_dtypes(include=['float64','float32','float16']).columns.values)
      print("non_categorical:",non_categorical)
      for nonCat in non_categorical:
          mean_val = np.mean(data[nonCat])
          #median_val = np.median(data[nonCat])
          if(np.isnan(mean_val)):
              mean_val = 0
              #np.around(mean_val, decimals=0)
          mean_val = round(mean_val, 2)
          print("mean_val:",mean_val," - column:",nonCat)
          data[nonCat].fillna(mean_val, inplace=True)

      print("Number of rows in data [Before Data Cleaning - But converting NAN/INF]:", data.shape[0])

      y = data.HasDetections
#      X = data[['ProductName','EngineVersion','AppVersion','AvSigVersion','IsProtected','Census_IsAlwaysOnAlwaysConnectedCapable','Wdft_IsGamer','Wdft_RegionIdentifier','Census_IsPenCapable']]
      X=data[['SmartScreen','AvSigVersion','CityIdentifier','Census_SystemVolumeTotalCapacity','Census_FirmwareVersionIdentifier','Census_ProcessorModelIdentifier','Census_OEMModelIdentifier','CountryIdentifier','OrganizationIdentifier',
                                 'Census_OSBuildRevision','GeoNameIdentifier','Census_OSVersion','Census_InternalPrimaryDiagonalDisplaySizeInInches',
                                 'LocaleEnglishNameIdentifier','Census_OSInstallTypeName','Census_PrimaryDiskTotalCapacity','Census_TotalPhysicalRAM',
                                 'AVProductStatesIdentifier','EngineVersion','Census_OEMNameIdentifier','Wdft_RegionIdentifier','AppVersion',
                                 'Census_FirmwareManufacturerIdentifier','Census_OSInstallLanguageIdentifier','Census_OSUILocaleIdentifier',
                                 'Census_InternalPrimaryDisplayResolutionHorizontal','Census_ProcessorCoreCount','Census_InternalPrimaryDisplayResolutionVertical','AVProductsInstalled',
                                 'Census_OSWUAutoUpdateOptionsName','Census_InternalBatteryNumberOfCharges','Census_ChassisTypeName',
                                 'Census_InternalBatteryType','Census_ActivationChannel','IeVerIdentifier','OsBuildLab','Census_PrimaryDiskTypeName',
                                 'Wdft_IsGamer',
                                 #'Census_IsSecureBootEnabled','Census_MDC2FormFactor','Census_OSBranch','Census_GenuineStateName',
                                 #'Census_OSEdition','Census_OSSkuName','Census_ProcessorManufacturerIdentifier','Census_OSBuildNumber','Census_PowerPlatformRoleName',
                                 #'OsBuild','Census_HasOpticalDiskDrive','OsPlatformSubRelease','Census_IsTouchEnabled','Census_FlightRing',
                                 ]]
      
      X_train, X_test, y_train, y_test = train_test_split(X, y)
      print(X.head())
      
      #standardization of data -- similar process for normalizaition
      scaler = StandardScaler()
      # Fit only to the training data
      scaler.fit(X_train)
      
      
      # Now apply the transformations to the data: it should be for test and train
      X_train = scaler.transform(X_train)
      X_test = scaler.transform(X_test)
      
      #safety checks
      print("has any NAN in X_train:",np.any(np.isnan(X_train)))
      print("has any NAN in y_train:",np.any(np.isnan(y_train)))
      print("isFinite in X_Train:",np.all(np.isfinite(X_train)))
      print("isFinite in y_Train:",np.all(np.isfinite(y_train)))
      
      
      self.mlp.fit(X_train,y_train)
#      self.clf.fit(X_train,y_train)
      print("--------------------------------- Start predict on sample data---------------------------------")
      #predict on sample data
      predictions = self.mlp.predict(X_test)
#      predictions = self.clf.predict(X_test)
      print(confusion_matrix(y_test,predictions))
      print(classification_report(y_test,predictions))
      print("--------------------------------- End of predict on sample data---------------------------------")

 
      
      # TODO adjust later to replace the categories with proper int or float numbers
#      X = data.drop('HasDetections', axis=1)
           # TODO cleanup the code 
      
##      X = X.dropna(subset=['Wdft_RegionIdentifier', 'Census_IsPenCapable'])
#      print('X:',X)
#      #print('y:',y)
#      X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1)
#      
#      self.clf.fit(X, y)
      

  #predicts the probablity of a machine affected by malware. The input test_data is a pandas dataframe.
  #This function must return the predicted probabilities for the test machines
  def predict_probablities(self, test_data):
      print("--------------------------------- Start predict on TEST data---------------------------------")
#      test_data= test_data[['ProductName','EngineVersion','IsProtected','Wdft_IsGamer','Wdft_RegionIdentifier','Census_IsPenCapable']]
#      test_data= test_data[['ProductName','EngineVersion','AppVersion','AvSigVersion','IsProtected','Census_IsAlwaysOnAlwaysConnectedCapable','Wdft_IsGamer','Wdft_RegionIdentifier','Census_IsPenCapable']]
      test_data=test_data[['SmartScreen','AvSigVersion','CityIdentifier','Census_SystemVolumeTotalCapacity','Census_FirmwareVersionIdentifier','Census_ProcessorModelIdentifier','Census_OEMModelIdentifier','CountryIdentifier','OrganizationIdentifier',
                                 'Census_OSBuildRevision','GeoNameIdentifier','Census_OSVersion','Census_InternalPrimaryDiagonalDisplaySizeInInches',
                                 'LocaleEnglishNameIdentifier','Census_OSInstallTypeName','Census_PrimaryDiskTotalCapacity','Census_TotalPhysicalRAM',
                                 'AVProductStatesIdentifier','EngineVersion','Census_OEMNameIdentifier','Wdft_RegionIdentifier','AppVersion',
                                 'Census_FirmwareManufacturerIdentifier','Census_OSInstallLanguageIdentifier','Census_OSUILocaleIdentifier',
                                 'Census_InternalPrimaryDisplayResolutionHorizontal','Census_ProcessorCoreCount','Census_InternalPrimaryDisplayResolutionVertical','AVProductsInstalled',
                                 'Census_OSWUAutoUpdateOptionsName','Census_InternalBatteryNumberOfCharges','Census_ChassisTypeName',
                                 'Census_InternalBatteryType','Census_ActivationChannel','IeVerIdentifier','OsBuildLab','Census_PrimaryDiskTypeName',
                                 'Wdft_IsGamer',
                                 #'Census_IsSecureBootEnabled','Census_MDC2FormFactor','Census_OSBranch','Census_GenuineStateName',
                                 #'Census_OSEdition','Census_OSSkuName','Census_ProcessorManufacturerIdentifier','Census_OSBuildNumber','Census_PowerPlatformRoleName',
                                 #'OsBuild','Census_HasOpticalDiskDrive','OsPlatformSubRelease','Census_IsTouchEnabled','Census_FlightRing',
                                 ]]
      
      
      print("handling categorical data in test_data with shape:",test_data.shape)
#      test_data = self.handleCategoricalData(test_data)
      categorical = list(test_data.select_dtypes(include=['object']).columns.values)
      print("captured categorical columns:",categorical)
      for category in categorical:
          test_data[category].fillna("NA", inplace=True)
          test_data[category] = [x.replace('.', '') for x in test_data[category]]
          #handling fields with combined String + float
          test_data[category] = self.labelEncoder.fit_transform(test_data[category].astype(str))
          
      non_categorical = list(test_data.select_dtypes(include=['float64','float32','float16']).columns.values)
      print("captured non_categorical columns:",non_categorical)
      for nonCat in non_categorical:
          mean_val = np.mean(test_data[nonCat])
          #median_val = np.median(data[nonCat])
          if(np.isnan(mean_val)):
              mean_val = 0
          mean_val = round(mean_val, 2)
          #filling NAN fields with MEAN value of the column
          print("mean_val:",mean_val," - column:",nonCat)
          test_data[nonCat].fillna(mean_val, inplace=True)
          
      #TODO Adjusting the return type shape
#      predictions = self.clf.predict_proba(test_data)[:, 1]
      predictions = self.mlp.predict(test_data)
      print("predictions:",predictions)    
#      print(confusion_matrix(test_data,predictions))
#      print(classification_report(test_data,predictions))
      print("--------------------------------- End of predict on TEST data---------------------------------")
      return predictions
 

#calls the train function and saves the model_file
#donot modify the contents
if __name__ == "__main__":
    detectionModel = MalwareDetectionModel()
    detectionModel.train()
    filename = 'malwaremodel.pkl'
    f = open(filename, 'wb')
    dill.dump(detectionModel, f)
    f.close()
