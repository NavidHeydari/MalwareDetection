import warnings
import numpy as np
import pandas as pd
import pickle
import dill
from sklearn.model_selection import train_test_split
from sklearn import tree
from sklearn.metrics import accuracy_score
from sklearn.metrics import auc, roc_curve
import sys 

#Donot modify the method signatures and return dtypes
#you can include additional functions of your choice


class MalwareDetectionModel:
  def __init__(self):
       self.dtypes = {
               'MachineIdentifier':                                    'category',
               'ProductName':  'category',
                'EngineVersion': 'category',
                'AppVersion': 'category',
                'AvSigVersion': 'category',
                'IsBeta': 'int64',
                'RtpStateBitfield': 'int64',
                'IsSxsPassiveMode': 'int64',
                'DefaultBrowsersIdentifier': 'int64',
                'AVProductStatesIdentifier': 'int64',
                'AVProductsInstalled': 'int64',
                'AVProductsEnabled': 'int64',
                'HasTpm': 'int64',
                'CountryIdentifier': 'int64',
                'CityIdentifier': 'int64',
                'OrganizationIdentifier': 'int64',
                'GeoNameIdentifier': 'int64',
                'LocaleEnglishNameIdentifier': 'int64',
                'Platform': 'category',
                'Processor': 'category',
                'OsVer': 'category',
                'OsBuild': 'int64',
                'OsSuite': 'int64',
                'OsPlatformSubRelease': 'category',
                'OsBuildLab': 'category',
                'SkuEdition': 'category',
                'IsProtected': 'int64',
                'AutoSampleOptIn': 'int64',
                'PuaMode': 'category',
                'SMode': 'int64',
                'IeVerIdentifier': 'int64',
                'SmartScreen': 'category',
                'Firewall': 'int64',
                'UacLuaenable': 'int64',
                'Census_MDC2FormFactor': 'category',
                'Census_DeviceFamily': 'category',
                'Census_OEMNameIdentifier': 'int64',
                'Census_OEMModelIdentifier': 'int64',
                'Census_ProcessorCoreCount': 'int64',
                'Census_ProcessorManufacturerIdentifier': 'int64',
                'Census_ProcessorModelIdentifier': 'int64',
                'Census_ProcessorClass': 'category',
                'Census_PrimaryDiskTotalCapacity': 'int64',
                'Census_PrimaryDiskTypeName': 'category',
                'Census_SystemVolumeTotalCapacity': 'int64',
                'Census_HasOpticalDiskDrive': 'int64',
                'Census_TotalPhysicalRAM': 'int64',
                'Census_ChassisTypeName': 'category',
                'Census_InternalPrimaryDiagonalDisplaySizeInInches': 'category',
                'Census_InternalPrimaryDisplayResolutionHorizontal': 'int64',
                'Census_InternalPrimaryDisplayResolutionVertical': 'int64',
                'Census_PowerPlatformRoleName': 'category',
                'Census_InternalBatteryType': 'category',
                'Census_InternalBatteryNumberOfCharges': 'int64',
                'Census_OSVersion': 'category',
                'Census_OSArchitecture': 'category',
                'Census_OSBranch': 'category',
                'Census_OSBuildNumber': 'int64',
                'Census_OSBuildRevision': 'int64',
                'Census_OSEdition': 'category',
                'Census_OSSkuName': 'category',
                'Census_OSInstallTypeName': 'category',
                'Census_OSInstallLanguageIdentifier': 'int64',
                'Census_OSUILocaleIdentifier': 'int64',
                'Census_OSWUAutoUpdateOptionsName': 'category',
                'Census_IsPortableOperatingSystem': 'int64',
                'Census_GenuineStateName': 'category',
                'Census_ActivationChannel': 'category',
                'Census_IsFlightingInternal': 'int64',
                'Census_IsFlightsDisabled': 'int64',
                'Census_FlightRing': 'category',
                'Census_ThresholdOptIn': 'int64',
                'Census_FirmwareManufacturerIdentifier': 'int64',
                'Census_FirmwareVersionIdentifier': 'int64',
                'Census_IsSecureBootEnabled': 'int64',
                'Census_IsWIMBootEnabled': 'int64',
                'Census_IsVirtualDevice': 'int64',
                'Census_IsTouchEnabled': 'int64',
                'Census_IsPenCapable': 'int64',
                'Census_IsAlwaysOnAlwaysConnectedCapable': 'int64',
                'Wdft_IsGamer': 'int64',
                'Wdft_RegionIdentifier': 'int64',
               #fill in the data types for the rest of the columns
               'HasDetections':                                        'int8'
               }
       #define the model in class level so all the methods can use it.
       self.clf = tree.DecisionTreeClassifier(max_depth=5)


  #trains a model, you can access the malware_train.csv file for training your model
  def train(self):
      fileName = sys.argv[1]

    # TODO clean up the input file in details and analysis of the NAN and empty or similar values
      data = pd.read_csv(fileName, index_col=0)
      data = data.dropna(how='all')
      data = data.dropna(subset=['Wdft_RegionIdentifier', 'Census_IsPenCapable','HasDetections'])
      #print(data.head())
#      print("Number of rows in data:", data.shape[0])
#      print(data.head())
      # Training and testing a decision tree
      y = data.HasDetections
      # TODO adjust later to replace the categories with proper int or float numbers
#      X = data.drop('HasDetections', axis=1)
           # TODO cleanup the code 
      X = data[['Wdft_RegionIdentifier','Census_IsPenCapable']]
##      X = X.dropna(subset=['Wdft_RegionIdentifier', 'Census_IsPenCapable'])
#      print('X:',X)
#      #print('y:',y)
#      X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1)
#      
      self.clf.fit(X, y)
      

  #predicts the probablity of a machine affected by malware. The input test_data is a pandas dataframe.
  #This function must return the predicted probabilities for the test machines
  def predict_probablities(self, test_data):
      #TODO delete this in my development
      test_data= test_data[['Wdft_RegionIdentifier','Census_IsPenCapable']]
      #TODO Adjusting the return type shape
      predictions = self.clf.predict_proba(test_data)[:, 1]
      print(predictions)
      
      return predictions
 

#calls the train function and saves the model_file
#donot modify the contents
if __name__ == "__main__":
    detectionModel = MalwareDetectionModel()
    detectionModel.train()
    filename = 'malwaremodel.pkl'
    f = open(filename, 'wb')
    dill.dump(detectionModel, f)
    f.close()
